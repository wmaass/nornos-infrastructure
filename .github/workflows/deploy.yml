name: Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
        - dev
        - staging
        - production
      service:
        description: 'Service to deploy (or "all")'
        required: true
        type: choice
        options:
        - all
        - patient-app
        - doctor-app
        - agent-service
        - relay-server
        - shared-data-server
        - auth-service
        - vault-server
      version:
        description: 'Version tag to deploy'
        required: true
        default: 'latest'

env:
  REGISTRY: ghcr.io
  REGISTRY_USER: ${{ github.repository_owner }}

jobs:
  # Approval gate for production
  approval:
    name: Approval
    runs-on: ubuntu-latest
    if: inputs.environment == 'production'
    environment: production-approval
    steps:
    - name: Production deployment approved
      run: echo "Production deployment approved"

  # Build and push Docker images
  build:
    name: Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: [approval]
    if: always() && (needs.approval.result == 'success' || inputs.environment != 'production')
    
    strategy:
      matrix:
        service: ${{ inputs.service == 'all' && fromJson('["patient-app", "doctor-app", "agent-service", "relay-server", "shared-data-server", "auth-service", "vault-server"]') || fromJson(format('["{0}"]', inputs.service)) }}
    
    steps:
    - name: Checkout app repository
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/nornos
        token: ${{ secrets.NORNOS_REPO_TOKEN }}

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./${{ matrix.service }}
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.REGISTRY_USER }}/nornos-${{ matrix.service }}:${{ inputs.version }}
          ${{ env.REGISTRY }}/${{ env.REGISTRY_USER }}/nornos-${{ matrix.service }}:${{ github.sha }}

  # Deploy infrastructure changes (Terraform)
  infrastructure:
    name: Infrastructure
    runs-on: ubuntu-latest
    needs: [approval]
    if: always() && (needs.approval.result == 'success' || inputs.environment != 'production')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0

    - name: Terraform Init
      run: terraform init
      working-directory: terraform/environments/${{ inputs.environment }}
      env:
        TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}

    - name: Terraform Plan
      run: terraform plan -out=tfplan
      working-directory: terraform/environments/${{ inputs.environment }}
      env:
        TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}

    - name: Terraform Apply
      if: inputs.environment != 'production' || github.event_name == 'workflow_dispatch'
      run: terraform apply -auto-approve tfplan
      working-directory: terraform/environments/${{ inputs.environment }}
      env:
        TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}

  # Deploy to Kubernetes
  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    needs: [build, infrastructure]
    environment: ${{ inputs.environment }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: v1.29.0

    - name: Install kustomize
      uses: imranismail/setup-kustomize@v2

    - name: Setup kubeconfig
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Update image tags
      run: |
        cd kubernetes/overlays/${{ inputs.environment }}
        
        if [ "${{ inputs.service }}" == "all" ]; then
          for svc in patient-app doctor-app agent-service relay-server shared-data-server auth-service vault-server; do
            kustomize edit set image nornos/$svc=${{ env.REGISTRY }}/${{ env.REGISTRY_USER }}/nornos-$svc:${{ inputs.version }}
          done
        else
          kustomize edit set image nornos/${{ inputs.service }}=${{ env.REGISTRY }}/${{ env.REGISTRY_USER }}/nornos-${{ inputs.service }}:${{ inputs.version }}
        fi

    - name: Deploy to Kubernetes
      run: |
        kustomize build kubernetes/overlays/${{ inputs.environment }} | kubectl apply -f -
        
        # Wait for rollout
        if [ "${{ inputs.service }}" == "all" ]; then
          for svc in patient-app doctor-app agent-service relay-server shared-data-server auth-service vault-server; do
            kubectl rollout status deployment/$svc -n nornos --timeout=300s || true
          done
        else
          kubectl rollout status deployment/${{ inputs.service }} -n nornos --timeout=300s
        fi

    - name: Verify deployment
      run: |
        kubectl get pods -n nornos
        kubectl get services -n nornos
        kubectl get ingress -n nornos

  # Post-deployment notification
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
    - name: Slack notification
      uses: slackapi/slack-github-action@v1.24.0
      with:
        payload: |
          {
            "text": "Deployment to ${{ inputs.environment }} ${{ needs.deploy.result == 'success' && 'succeeded' || 'failed' }}",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Deployment ${{ needs.deploy.result == 'success' && 'Complete' || 'Failed' }}* ${{ needs.deploy.result == 'success' && ':white_check_mark:' || ':x:' }}\n*Environment:* ${{ inputs.environment }}\n*Service:* ${{ inputs.service }}\n*Version:* ${{ inputs.version }}"
                }
              }
            ]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      continue-on-error: true
